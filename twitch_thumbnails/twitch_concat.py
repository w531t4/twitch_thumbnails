# Copyright (c) 2025 w531t4
#
# This file is licensed under the MIT License.
# See the LICENSE file in the project root for full license text.

import io
from typing import Tuple, Dict, Any, List
from pathlib import Path
import requests
from PIL import Image
import appdaemon.plugins.hass.hassapi as hass


class TwitchConcat(hass.Hass):
    """  Resize and Concatenate twitch.tv channel icons horizontally """
    def initialize(self):
        """ Gather attributes from apps.yaml, otherwise set defaults """
        self.args: Dict[str, Any]
        self.entity   = self.args.get("entity", "sensor.twitch_online_streamers")
        self.attr     = self.args.get("attribute", "online_detail")
        self.size     = self.args.get("size", [32, 32])  # w,h
        self.out_dir  = Path(self.args.get("out_dir", "/config/www/twitch"))
        self.out_file = Path(self.args.get("out_file", "online_strip.bmp"))
        self.format   = "BMP" if str(self.out_file).lower().endswith(".bmp") else "PNG"
        self.max_entries = self.args.get("max_entries", 10)
        self.publish_entity = self.args.get("entity", "sensor.twitch_online_streamers_published")
        self.out_dir.mkdir(exist_ok=True)
        # run once, then on every change
        self.run_in(self._build, 1)
        self.listen_state(self._on_change, self.entity, attribute=self.attr)
        self.attr_data = None

    @property
    def entity(self) -> str:
        """ entity_id from homeassistant """
        return self._entity

    @entity.setter
    def entity(self, data) -> None:
        self._entity = data

    @property
    def size(self) -> Tuple[int, int]:
        """ target dimensions of each icon (in px)"""
        return self._size

    @size.setter
    def size(self, data) -> None:
        self._size = tuple(data)

    @property
    def out_dir(self) -> Path:
        """ directory in which to write a generated image into """
        return self._out_dir

    @out_dir.setter
    def out_dir(self, data: Path) -> None:
        self._out_dir = data

    @property
    def out_file(self) -> Path:
        """ Name of the file generated by the script """
        return self._out_file

    @out_file.setter
    def out_file(self, data: Path) -> None:
        self._out_file = data

    @property
    def attr(self) -> str:
        """ attribute (from entity) containing desired data """
        return self._attr

    @attr.setter
    def attr(self, data) -> None:
        self._attr = data

    @property
    def format(self) -> str:
        """ Target image format """
        return self._format

    @format.setter
    def format(self, data) -> None:
        self._format = data

    @property
    def max_entries(self) -> int:
        """ max number of icons to render """
        return self._max_entries

    @max_entries.setter
    def max_entries(self, data) -> None:
        assert data > 0, f"max_entries must be a value > 0. observed={data}"
        self._max_entries = data

    def _on_change(self, *args, **kwargs):
        self._build({})

    def _fetch_and_fit(self, url: str) -> Image.Image | None:
        try:
            r = requests.get(url, timeout=10)
            r.raise_for_status()
            im = Image.open(io.BytesIO(r.content)).convert("RGBA")
            # letterbox to square then resize -> keeps aspect
            width, height = im.size
            max_wh = max(width, height)
            bg = Image.new("RGB", (max_wh, max_wh), (0, 0, 0))
            bg.paste(im, ((max_wh - width)//2, (max_wh - height)//2), im)
            return bg.resize(self.size, Image.Resampling.LANCZOS)
        except Exception as e:
            self.log(f"fetch fail {url}: {e}", level="WARNING")
            return None

    def _build(self, kwargs):
        data: List[Dict[str, str]] = \
            self.get_state(self.entity,
                           attribute=self.attr) # type: ignore[reportAssignmentType]
        self.attr_data = data
        self.log(f"observed state_data={data}", level="DEBUG")
        icons: List[Image.Image] = []

        if data:
            try:
                items = data
                for obj in sorted(items,
                                  key=lambda x: int(x["followers"]),
                                  reverse=True)[:self.max_entries]:
                    url = obj.get("offline_picture")
                    if not url or not url.startswith(("http://","https://")):
                        continue
                    thumb = self._fetch_and_fit(url)
                    if thumb:
                        icons.append(thumb)
            except Exception as e:
                self.log(f"JSON error: {e}", level="WARNING")

        # Pad to exactly 12 icons with solid black 32x32
        width, height = self.size
        while len(icons) < self.max_entries:
            icons.append(Image.new("RGB", (width, height), (0, 0, 0)))

        # Build fixed-width strip: 12 * 32 wide
        total_w = width * self.max_entries
        strip = Image.new("RGB", (total_w, height), (0, 0, 0))
        x = 0
        for im in icons[:self.max_entries]:
            strip.paste(im, (x, 0))
            x += width

        # Save
        out_path = self.out_dir / str(self.out_file)
        # out_path = os.path.join(self.out_dir, self.out_file)
        if self.format == "BMP":
            # Save as RGB BMP
            strip.convert("RGB").save(str(out_path), format="BMP")
        else:
            strip.save(str(out_path), format="PNG", optimize=True)

        self.log(f"Wrote {out_path} ({strip.size[0]}x{strip.size[1]})")
        assert self.attr_data is not None
        self.set_state(entity_id=self.publish_entity, attributes={self.attr: self.attr_data})
